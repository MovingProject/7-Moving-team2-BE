// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id                       String            @id @default(uuid())
  name                     String
  email                    String            @unique
  passwordHash             String?
  phoneNumber              String
  role                     Role
  providerId               String?
  provider                 String?
  createdAt                DateTime          @default(now())
  updatedAt                DateTime          @updatedAt
  deletedAt                DateTime?
  driverProfile            DriverProfile?
  consumerProfile          ConsumerProfile?
  consumerLikes            LIKE[]            @relation("ConsumerLikesDriver") // 내가 소비자(consumer)로서 누군가(기사)를 좋아요한 기록들
  likedByConsumers         LIKE[]            @relation("DriverLikedByConsumer") // 내가 기사(driver)로서 소비자에게 받은 좋아요들
  requestsAsConsumer       Request[]         @relation("RequestsByConsumer")
  reviewsWritten           Review[]          @relation("ReviewsByConsumer")
  reviewsReceived          Review[]          @relation("ReviewsForDriver")
  quotationsAsConsumer     Quotation[]       @relation("QuotationsByConsumer")
  quotationsAsDriver       Quotation[]       @relation("QuotationsForDriver")
  chatRoomsAsConsumer      ChattingRoom[]    @relation("RoomsByConsumer")
  chatRoomsAsDriver        ChattingRoom[]    @relation("RoomsByDriver")
  chattingMessages         ChattingMessage[]
  receivedNotifications    Notification[]    @relation("ReceivedNotifications")
  sentNotifications        Notification[]    @relation("SentNotifications")
  refreshTokens            RefreshToken[]
  invitesAsDriver          Invite[]
  driverRequestActions     DriverRequestAction[]
  chatMessageReads         ChatMessageRead[]
  @@unique([provider, providerId])
}

model RefreshToken {
  id        String    @id @default(uuid())
  jti       String    @unique @default(dbgenerated("gen_random_uuid()"))
  tokenHash String    @unique
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([userId, expiresAt])
}

enum Role {
  DRIVER
  CONSUMER
}

model DriverProfile {
  id                 String              @id @default(uuid())
  userId             String              @unique
  driver             User                @relation(fields: [userId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  image              String?
  nickname           String
  careerYears        String
  oneLiner           String
  description        String
  likeCount          Int                 @default(0)
  rating             Float               @default(0.0)
  reviewCount        Int                 @default(0)
  confirmedCount     Int                 @default(0)
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  deletedAt          DateTime?
  driverServiceAreas DriverServiceArea[]
  driverServiceTypes DriverServiceType[]
}

model DriverServiceArea {
  id              String        @id @default(uuid())
  driverProfileId String
  driverProfile   DriverProfile @relation(fields: [driverProfileId], references: [id], onDelete: Cascade)
  serviceArea     Area
}

model DriverServiceType {
  id              String        @id @default(uuid())
  driverProfileId String
  driverProfile   DriverProfile @relation(fields: [driverProfileId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  serviceType     MoveType
}

model LIKE {
  id        String  @id @default(uuid())
  consumerId String
  consumer   User   @relation("ConsumerLikesDriver", fields: [consumerId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  driverId   String
  driver     User   @relation("DriverLikedByConsumer", fields: [driverId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  likedAt    DateTime @default(now())
  @@unique([consumerId, driverId])
  @@index([consumerId, likedAt(sort: Desc), id(sort: Desc)])
}

enum MoveType {
  SMALL_MOVE
  HOME_MOVE
  OFFICE_MOVE
}

enum Area {
  SEOUL
  GYEONGGI
  INCHEON
  GANGWON
  CHUNGBUK
  CHUNGNAM
  SEJONG
  DAEJEON
  JEONBUK
  JEONNAM
  GWANGJU
  GYEONGBUK
  GYEONGNAM
  DAEGU
  ULSAN
  BUSAN
  JEJU
}

// @Todo: consumerProfile의 지역은 하나의 지역만 설정이 가능하다.
// 그러므로 areas를 area로 수정하는 작업이 필요
model ConsumerProfile {
  id              String         @id @default(uuid())
  consumerId      String         @unique
  consumer        User           @relation(fields: [consumerId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  image           String?
  serviceType     MoveType
  areas           Area
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  deletedAt       DateTime?
}

model Request { 
  id                     String   @id @default(uuid()) 
  consumerId             String
  consumer               User    @relation("RequestsByConsumer", fields: [consumerId], references: [id], onUpdate: Cascade, onDelete: Restrict) 
  serviceType            MoveType 
  moveAt                 DateTime @db.Date
  departureAddress       String 
  departureFloor         Int 
  departurePyeong        Float
  departureElevator      Boolean 
  arrivalAddress         String 
  arrivalFloor           Int 
  arrivalPyeong          Float
  arrivalElevator        Boolean
  additionalRequirements String? 
  departureArea          Area 
  arrivalArea            Area 
  requestStatus          RequestStatus @default(PENDING)
  generalQuoteCount   Int @default(0)
  invitedQuoteCount   Int @default(0)
  generalQuoteLimit   Int @default(5)
  invitedQuoteLimit   Int @default(3)
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
  concludedAt            DateTime?
  completedAt            DateTime?
  expiredAt              DateTime?
  canceledAt             DateTime?
  withdrawnAt            DateTime?
  deletedAt              DateTime?  
  invites                Invite[] 
  driverRequestActions   DriverRequestAction[]
  chattingRooms          ChattingRoom[]
  quotations             Quotation[]
  notifications          Notification[]
  @@index([consumerId, requestStatus, createdAt(sort: Desc)], map: "Request_pending_lookup")
  @@index([departureArea])
  @@index([arrivalArea])
}

enum RequestStatus {
  PENDING 
  CONCLUDED
  COMPLETE
  EXPIRED
  CANCELED   
  WITHDRAWN
}

model Invite { 
  id         String    @id @default(uuid()) 
  requestId  String 
  request    Request   @relation(fields: [requestId], references: [id], onDelete: Cascade) 
  driverId   String 
  driver     User      @relation(fields: [driverId], references: [id], onDelete: Cascade) 
  createdAt  DateTime  @default(now()) 
  canceledAt DateTime? 
  @@unique([requestId, driverId]) 
  @@index([driverId]) 
} 

model DriverRequestAction { 
  id         String @id @default(uuid()) 
  requestId  String 
  request    Request @relation(fields: [requestId], references: [id], onDelete: Cascade) 
  driverId   String 
  driver     User @relation(fields: [driverId], references: [id], onDelete: Cascade) 
  state      ActionState 
  source     ActionSource 
  note       String? 
  createdAt  DateTime @default(now()) 
  updatedAt  DateTime @updatedAt 
  @@unique([requestId, driverId]) 
  @@index([driverId, state]) 
  @@index([requestId, state]) 
} 

enum ActionState { 
  ACCEPTED 
  REJECTED 
} 

enum ActionSource { 
  GENERAL 
  INVITED 
}

model ChattingRoom {
  id              String          @id @default(uuid())
  consumerId      String
  consumer        User            @relation("RoomsByConsumer", fields: [consumerId], references: [id], onUpdate: Cascade, onDelete: Restrict)
  driverId        String
  driver          User            @relation("RoomsByDriver", fields: [driverId], references: [id], onUpdate: Cascade, onDelete: Restrict)
  requestId       String
  request         Request         @relation(fields: [requestId], references: [id], onUpdate: Cascade, onDelete: Restrict)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  deletedAt       DateTime?
  closedAt        DateTime?       
  quotations      Quotation[]
  messages        ChattingMessage[]
  notifications   Notification[]
  @@unique([requestId, driverId]) 
  @@index([consumerId, createdAt]) 
  @@index([driverId, createdAt])  
}

model ChattingMessage {
  id             String        @id @default(uuid())
  chattingRoomId String
  chattingRoom   ChattingRoom  @relation(fields: [chattingRoomId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  senderId       String
  sender         User          @relation(fields: [senderId], references: [id], onUpdate: Cascade, onDelete: Restrict)
  messageType    MessageType
  quotation      Quotation?
  content        String?        @db.Text
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  chatMessageReads ChatMessageRead[]
  @@index([chattingRoomId, createdAt]) 
}

model ChatMessageRead {
  messageId  String
  message    ChattingMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  userId     String
  user       User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  readAt     DateTime        @default(now())
  @@id([messageId, userId])  
  @@index([userId, readAt])
}

enum MessageType {
  MESSAGE
  QUOTATION
}

model Quotation { 
 id                     String @id @default(uuid()) 
 consumerId             String 
 consumer               User @relation("QuotationsByConsumer", fields: [consumerId], references: [id], onUpdate: Cascade, onDelete: Restrict) 
 driverId               String 
 driver                 User @relation("QuotationsForDriver", fields: [driverId], references: [id], onUpdate: Cascade, onDelete: Restrict) 
 chattingRoomId         String 
 chattingRoom           ChattingRoom @relation(fields: [chattingRoomId], references: [id], onUpdate: Cascade, onDelete: Restrict) 
 requestId              String 
 request                Request @relation(fields: [requestId], references: [id], onUpdate: Cascade, onDelete: Restrict) 
 serviceType            MoveType 
 moveAt                 DateTime @db.Date 
 departureAddress       String 
 departureFloor         Int 
 departurePyeong        Float 
 departureElevator      Boolean 
 arrivalAddress         String 
 arrivalFloor           Int 
 arrivalPyeong          Float 
 arrivalElevator        Boolean 
 additionalRequirements String? 
 price                  Int 
 status                 QuotationStatus @default(SUBMITTED)
 previousQuotationId    String?
 previousQuotation      Quotation?  @relation("QuotationRevisions", fields: [previousQuotationId], references: [id], onDelete: SetNull)
 nextRevisions          Quotation[] @relation("QuotationRevisions")
 selectedAt             DateTime? 
 validUntil             DateTime? 
 createdAt              DateTime @default(now()) 
 updatedAt              DateTime @updatedAt 
 deletedAt              DateTime? 
 review                 Review?
 chattingMessageId      String          @unique
 chattingMessage        ChattingMessage @relation(fields: [chattingMessageId], references: [id], onUpdate: Cascade, onDelete: Restrict)
 notifications          Notification[]
 @@index([driverId, createdAt]) 
 @@index([consumerId, createdAt]) 
 @@index([requestId, createdAt]) 
 @@index([chattingRoomId, createdAt]) 
 } 

 enum QuotationStatus { 
 SUBMITTED 
 REVISED 
 WITHDRAWN 
 SELECTED 
 EXPIRED 
 }

model Review { 
 id            String @id @default(uuid()) 
 consumerId    String 
 consumer      User @relation("ReviewsByConsumer", fields: [consumerId], references: [id], onUpdate: Cascade, onDelete: Restrict) 
 driverId      String 
 driver        User @relation("ReviewsForDriver", fields: [driverId], references: [id], onUpdate: Cascade, onDelete: Restrict) 
 content       String @db.Text
 rating        Int 
 quotationId   String @unique
 quotation     Quotation @relation(fields: [quotationId], references: [id], onUpdate: Cascade, onDelete: Restrict) 
 createdAt     DateTime @default(now()) 
 updatedAt     DateTime @updatedAt 
 deletedAt     DateTime? 
 notifications Notification[]
 }

model Notification {
  id               String           @id @default(uuid())
  receiverId       String
  receiver         User             @relation("ReceivedNotifications", fields: [receiverId], references: [id], onDelete: Cascade)
  senderId         String?
  sender           User?            @relation("SentNotifications", fields: [senderId], references: [id], onDelete: SetNull)
  content          String           @db.Text
  notificationType NotificationType
  createdAt        DateTime         @default(now())
  readAt           DateTime?        
  requestId        String?
  request          Request?         @relation(fields: [requestId], references: [id], onDelete: SetNull)
  quotationId      String?
  quotation        Quotation?       @relation(fields: [quotationId], references: [id], onDelete: SetNull)
  chattingRoomId   String?
  chattingRoom     ChattingRoom?    @relation(fields: [chattingRoomId], references: [id], onDelete: SetNull)
  reviewId         String?
  review           Review?          @relation(fields: [reviewId], references: [id], onDelete: SetNull)
  @@index([receiverId, readAt])
  @@index([receiverId, createdAt])
}

enum NotificationType {
  NEW_QUOTATION
  QUOTATION_ACCEPTED
  NEW_MESSAGE
  REVIEW_RECEIVED
  INVITE_RECEIVED
  INVITE_CANCELLED
  REQUEST_CONCLUDED
  REQUEST_COMPLETED
  REQUEST_EXPIRED
  MOVE_DAY_REMINDER
}